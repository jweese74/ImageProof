Thank you! I’ll now create a detailed roadmap for the ImageProof project that remains within 20 files total, including frontend, backend, and database definitions. Each file will have a plain-English name and include a high-level description of its purpose along with its major functions or responsibilities.

I'll let you know as soon as it’s ready to review.


# ImageProof Project Structure and File Overview

Below is the proposed structure for the **ImageProof** project, limited to 20 core files (including SQL schema files). Each file or module is described with its purpose and the key functions or components it contains. This roadmap emphasizes robustness, security, and clarity, providing a high-level guide for implementation. All functions and files are named descriptively, and their roles are explained in plain English.

## 1. `app.py` – Application Entrypoint & Initialization

**Purpose:** This is the main entry point of the backend application (Flask or FastAPI). It initializes the web app, configures global settings (like database and security), and registers all routes/blueprints for public, member, and admin sections. It ensures the server runs with HTTPS and other security middleware.

**Key Functions/Components:**

* `create_app()`: Configures and creates the Flask/FastAPI application object. It loads configuration (from `config.py`), initializes extensions (database ORM, CORS, rate limiting, etc.), and registers blueprints for different route groups (public, member, admin). It also sets up global security measures such as **HTTPS enforcement** (e.g., redirect HTTP to HTTPS), strict CORS policies for APIs, and request logging.
* `init_db()`: Connects to the database (using SQLAlchemy or a similar ORM). It can create database tables on startup (for example, by calling the ORM’s model metadata or running migrations) if they don’t exist. This function may also load initial seed data (licenses, templates) if needed.
* **Middleware/Setup:** On app startup, this file ensures **CSRF protection** is enabled for form routes (if using Flask-WTF, the CSRF is auto-handled; otherwise, a CSRF token check can be added to incoming POST requests). It also integrates any **rate limiting** (e.g., using Flask-Limiter) to prevent abuse of public endpoints (like image lookup) and configures **session management** for logged-in users. All blueprint routes defined in other files are attached here with appropriate URL prefixes (e.g., `/admin` for admin routes).

## 2. `config.py` – Configuration Settings

**Purpose:** Defines configuration variables for different environments and security settings. This file centralizes app settings such as database connection strings, secret keys, and feature toggles, allowing easy adjustments without modifying code.

**Contents/Functions:**

* **Configuration Variables:** Contains constants like `DATABASE_URI` (for MariaDB connection), `SECRET_KEY` (for sessions/CSRF), file upload size limits, allowed image file extensions, and hashing salts or pepper for added security. It also defines paths for file storage (e.g., directories for temporary files, stored watermark/signature images) and toggles for features like debug mode.
* **Security Settings:** Includes parameters for security features: e.g., `HTTPS_ONLY = True`, `MAX_CONTENT_LENGTH` to limit upload size, and CORS allowed origins if using an API. May also specify password policy (minimum length, etc.), and token expiry times for things like email verification links or API keys.
* **Config Classes (Optional):** If needed, uses classes for different environments (Dev, Prod) inheriting common settings. For example, `class ProductionConfig` vs `class DevelopmentConfig` to adjust debug, logging, or DB endpoints.
  *(No complex functions are expected here; it primarily provides variables. Utility functions to retrieve config or environment variables can be included if necessary, e.g., `get_db_uri()`.)*

## 3. `models.py` – Database Models and Schema Definitions

**Purpose:** Defines the database schema through ORM models (using SQLAlchemy, Peewee, or similar). It contains data models for users, images, overlays, and logs, encapsulating the fields described in the ImageProof metadata schema. These models include relationships and can have helper methods for common queries.

**Key Components (Classes):**

* **`User` Model:** Represents registered users (members and admins). Fields include `id`, `email`, `username` (or name), `password_hash` (securely stored via bcrypt/PBKDF2), `role` (e.g., "Guest", "Member", "Admin"), `email_verified` (boolean), and `mfa_secret` or `mfa_enabled` for two-factor auth. It may also store `created_at` and `last_login`. Methods could include `check_password(password)` to verify credentials and relationships to images (one-to-many).
* **`ImageRecord` Model:** Represents a registered artwork entry. Fields cover the **Image Metadata Schema**: e.g., `id`, `title`, `description`, `creation_date`, `keywords`, `creator_name`, `copyright_notice`, `license_type`, etc., as well as technical fields like `sha256_hash` (CHAR(64)), `md5_hash` (CHAR(32)), `perceptual_hash` (for quick similarity lookup), and `fingerprint` (a composite or JSON field storing additional fingerprint data like ORB features). It also includes `owner_id` (foreign key to User or null if guest), `status` (ENUM: "Certified", "Disputed", "Revoked", etc.), and flags like `is_public` (if the owner allows public verification of this image). **Timestamps** (e.g., `registered_at`) and an `uploader_ip` or `upload_agent` may be stored for audit and replay-attack prevention (to detect duplicate uploads from different sources).
* **`OverlayImage` Model:** (Optional) Represents an image overlay (such as a signature or watermark graphic) uploaded by a verified user or admin. Fields might include `id`, `user_id` (who owns this overlay), `file_path` or `image_data` (where the overlay image is stored), `type` (ENUM: "signature" or "watermark"), and perhaps a `name/label` for user to identify it. This separates persistent overlay images from the main ImageRecord (since the actual artwork image is not stored persistently). Members can have multiple overlays associated with them for reuse.
* **`ActionLog` Model:** (Optional but recommended for auditing) Logs significant actions and events. Fields: `id`, `user_id` (who performed action, nullable for system events), `image_id` (if related to an image), `action` (text like "REGISTER", "MODIFY", "TRANSFER", "FLAG", "LOGIN\_FAIL", etc.), `timestamp`, and `details` (JSON or text with extra info like IP address, previous and new values, etc.). This provides an audit trail that both users and admins can review.

**Notes:** Each model class may also include methods or properties for convenience. For example, `ImageRecord` might have a method `generate_certificate_data()` to format its info for a certificate, or `User` might have `enable_mfa()` to set up two-factor authentication. All text fields are stored in a safe format (after sanitization via `utils.py`). The ORM will handle relationships (e.g., `User.images` back-reference for all images by a user). The schema enforces data integrity with foreign keys (e.g., if an image is owned by a user, `owner_id` references `User.id`).

## 4. `utils.py` – Utility Functions (Validation, Security, Helpers)

**Purpose:** A collection of helper functions for common tasks such as input sanitization, hashing, and validations. This ensures **security** and avoids code duplication. Many other modules will call functions from `utils.py` for checking user input, scanning files, or generating secure hashes/tokens.

**Key Functions:**

* `sanitize_text(input_str)`: Cleans user-provided text fields (title, description, etc.) by stripping disallowed HTML tags or scripts, trimming whitespace, and escaping special characters. Ensures that data stored in the database or displayed is safe (preventing XSS or SQL injection when ORM is not handling it).
* `is_allowed_file(filename)`: Checks the file extension (and potentially file signature) of an uploaded image against a whitelist (e.g., `.png, .jpg, .jpeg`). This helps reject potentially dangerous file types.
* `validate_image_file(file_stream)`: Reads a few bytes of the file to verify it is a valid image (using Pillow to open it, for example). May also enforce size and dimension limits. If the image is malformed or exceeds limits, this function returns an error or exception.
* `scan_file_for_viruses(file_path)`: Uses an antivirus scanner (like ClamAV) to scan the uploaded file for malware. This can be called on any user-uploaded image (or overlay) before processing. If a threat is detected, the process is aborted and the user is notified.
* `hash_password(password)`: Takes a plaintext password and returns a securely hashed version (using bcrypt or PBKDF2 with salt). This ensures that stored passwords are not in plain text.
* `verify_password(password, hashed)`: Verifies a plaintext password against the stored hash (the inverse of `hash_password`). Used during login.
* `generate_csrf_token()` and `validate_csrf_token(token)`: (If not using a framework-provided solution) Generates a random CSRF token (e.g., a secure random string stored in session) and validates a token from incoming form data to protect against CSRF attacks. These would be used in forms like image registration and login.
* `generate_api_key()` and `verify_api_key(key)`: Creates a random token for API authentication (for future API usage or internal service calls) and verifies a given API key against records (e.g., for certain endpoints that require a token). This ties into **strict API key validation** for any open API endpoints.
* `rate_limit_exceeded(client_id)`: (If implementing custom rate limiting) Checks if a given client (identified by IP or user account) has exceeded allowed request rates. Could integrate with an in-memory store or use an external library, but a helper is listed here for completeness.
* `log_event(user, action, details)`: Adds an entry to the ActionLog (or log file) for auditing. For example, record when an image is registered, when a login fails, or a suspicious re-upload is attempted. This helps implement **anomaly detection** by analyzing logs.

**Note:** All these functions return clear status or raise exceptions that the calling routes will handle, providing feedback to the user (without revealing sensitive info). By centralizing these utilities, the app maintains consistency in how it handles security-critical operations.

## 5. `auth.py` – Authentication & Authorization Logic

**Purpose:** Manages user authentication (login/logout) and account-related operations like registration, email verification, and multi-factor auth. It also houses decorators or helper functions to enforce authorization (role-based access control) on routes. This ensures only permitted users (Member, Admin, etc.) can access certain functionalities.

**Key Functions:**

* `register_user(form_data)`: Processes a new user signup. It validates the registration form (ensuring email format, password strength, CAPTCHA verification if enabled), creates a new `User` in the database with role "Member" (or other appropriate role), and sends a verification email with a token link. The email includes a unique token (generated securely, e.g., JWT or a signed serializer) to confirm the email address. This function does **rate limiting** on how often an IP or email can attempt to register to prevent abuse.
* `confirm_email(token)`: Confirms a user's email address given a verification token. It locates the user account associated with the token, activates email\_verified status, and allows login. If token is invalid or expired, it returns an error.
* `login_user(email, password, mfa_code=None)`: Authenticates a user. It verifies the email exists and password matches (using `utils.verify_password`). If the user’s account has MFA enabled, it also verifies the one-time code (`mfa_code`) from an authenticator app or email. On success, it creates a session (for Flask, using session cookies) or returns an auth token (for API usage). It resets login attempt counters on success. On failure, it logs the attempt and increments a secure counter to possibly lock the account or trigger additional verification after several failures.
* `logout_user()`: Logs the user out by clearing their session or authentication token. Ensures any sensitive session data is wiped.
* `init_mfa(user)`: Begins multi-factor authentication enrollment for a user. For example, generates a secret key for TOTP (Time-based One-Time Password apps like Google Authenticator) or prepares an SMS/email code flow. It might return a QR code for the user to scan with an authenticator app. This function would be invoked when a user opts in to MFA in their account settings.
* `verify_mfa_token(user, token)`: Checks a provided MFA code against the user’s registered MFA method (e.g., verifies TOTP code using the stored secret). Used during login or during MFA setup verification.
* `require_login(role=None)`: **Decorator** or helper for route protection. Ensures the request has an authenticated user. If `role` is provided, also checks the user’s role matches (e.g., admin-only routes). It will redirect unauthorized users to login or return a 403 status for API calls. For example, `@require_login(role="Admin")` on admin routes.
* `can_access_image(user, image_record)`: Helper that checks if a given user is allowed to view or modify a particular image record. For instance, owners can edit their images, admins can see everything, members can search public records, but guests might have restricted access. This encapsulates the rules (guests can only see guest-submitted images, etc.) so that route handlers can simply call this to enforce access control.
* `verify_captcha(captcha_response)`: (If using CAPTCHAs for bot prevention) Validates the CAPTCHA token from forms like registration or image submission against the CAPTCHA service (e.g., reCAPTCHA). This is invoked during user registration or possibly guest image uploads to block automated abuse.

**Notes:** This module focuses on user accounts. It collaborates with `utils.py` for things like password hashing and with `models.py` to create or update user records. By separating auth logic, we ensure the core routes remain clean and all security checks are consistently applied.

## 6. `routes_public.py` – Public Routes (Unauthenticated Access)

**Purpose:** Defines the endpoints that are accessible without login (for guests or general public). These include the home page, public lookup features, and guest image registration. The routes here are carefully limited to protect the system while offering basic functionality to non-members.

**Key Routes/Functions:**

* `home_page()`: Serves the landing page (e.g., rendering `index.html`). This page can highlight the platform’s purpose and provide a form for quick image lookup (by hash or by uploading an image to check authenticity). It may also allow guests to proceed to fingerprint an image without logging in.
* `lookup_image()`: Handles public image lookup requests. Users can input an image’s fingerprint (hash) or upload an image to search for matches. The function will accept a hash string or an image file:

  * If a hash is provided, it searches the database for an exact match or close perceptual hash matches.
  * If an image file is provided, it uses `image_processing.py` to compute a perceptual hash (and possibly other fingerprint data) on the fly, then compares against stored records for similarity.
    Results are returned as a result page or JSON. For each matched record, it shows publicly viewable info: e.g., whether the image is registered, the registration date, and artist name if the record is public. **Security/Privacy:** If a record is marked private by its owner, or belongs to a Member, a guest lookup might either not return it or return a very minimal confirmation (e.g., "Registered (Private)" without details). Guest users **cannot** see full metadata of member-owned images. They are primarily limited to verifying guest-submitted works or being told that an image is registered (without further detail) unless they log in. Rate limiting is applied here to prevent abuse by bots.
* `register_image_guest()`: Allows a guest (not logged in) to register/fingerprint an artwork image anonymously. This route would present a simplified form (only essential metadata and **text-based watermark option**, since guests cannot upload custom signature images). Upon form submission, it will:

  1. Validate input and image (using `utils.py` for sanitization and file checks, plus a CAPTCHA to prevent spam).
  2. Generate the image’s fingerprint and hashes via `image_processing.py`.
  3. Optionally apply a text watermark if the guest provided watermark text (using `watermark.py`). Guests are restricted to at most one text overlay for simplicity.
  4. Store the new `ImageRecord` in the database with `owner_id = NULL` (or a special guest account) and mark it as a **Guest submission**. Only minimal metadata might be stored to protect guest privacy (for instance, might not store a creator name unless provided).
  5. Return a confirmation page or package to the user. For guests, since no account, the output could be directly a download (e.g., a ZIP with the watermarked image and a basic proof PDF/JSON). They will not have a dashboard to retrieve it later. **No original image is stored on the server** beyond this request.
     This function ensures guests cannot register more than a certain number of images per day (to prevent abuse), by checking IP-based rate limits. It also logs the action with the IP and fingerprint to detect if the same image is being re-uploaded.
* `view_image_public(hash_id)`: (Optional) A public endpoint to view an image’s details by its hash or ID. This would be used when someone scans a QR code or visits a lookup link (as mentioned for certificates). It shows verification info: e.g., "Image X is registered to Artist Y on Date Z". For non-logged users, this will show information only if the image’s owner chose to make it public. Guest-submitted images are generally public by nature (since no owner), so those would display basic metadata. Member images might show limited info or require login.

**Note:** All public routes are designed to never modify data (except the guest registration which creates a record) and are protected against spam or malicious use. Forms include CSRF tokens and CAPTCHAs where appropriate. The public lookup will not expose sensitive details—if an image is found but is private or the user has no rights to see details, it will simply indicate that the image is registered or require login for more info.

## 7. `routes_member.py` – Member Dashboard & Authenticated Routes

**Purpose:** Contains routes accessible to logged-in members (standard users). These allow users to manage their registered images, perform lookups across the full registry, and utilize advanced features like overlay management and ownership transfer. All routes here require authentication and possibly verification of email/MFA depending on the action’s sensitivity.

**Key Routes/Functions:**

* `dashboard()`: Serves the member’s dashboard page (`dashboard.html`). This shows an overview of the user’s activity: a list of the images they have registered (with key metadata like title, registration date, status), and quick links to actions (view details, download certificate, transfer, etc.). It may also display notifications (e.g., if one of their images was flagged or if a transfer is pending).
* `register_image_member()`: Handles the image registration form for logged-in users (from `register_image.html`). This is a core function that orchestrates the entire fingerprinting workflow for members:

  1. **Input Handling:** Receives the uploaded original image file and the filled metadata form (title, description, creation date, etc.). It also accepts user’s choices for overlays: they might input watermark text, and/or choose one of their uploaded signature images, and optionally an additional watermark image. Up to three overlays are allowed in any combination, as per the spec.
  2. **Validation:** Uses `utils.py` to sanitize all text fields and validate the image file (type, size) and overlay files if any. Ensures required fields (like title, creator name) are present. Also checks that the user is allowed the chosen actions (e.g., if a free-tier member has a certain limit, or if using an overlay image belongs to them).
  3. **Hashing/Fingerprinting:** Calls `image_processing.create_fingerprint(original_image)` to compute the SHA-256, perceptual hash, and any other fingerprint data. This uniquely identifies the image content. The system checks in the database if this fingerprint already exists (potential duplicate). If found: it might alert the user or mark the new entry as disputed if the existing one has a different owner. (This is part of **replay attack and duplicate protection**.)
  4. **Applying Overlays:** If the user provided watermark text or signature images, uses `watermark.py` to overlay them onto the image. This produces a final watermarked image (which the user will receive). The original image is **not stored** permanently – it’s used to generate hashes and the watermarked version, then discarded or kept only in a temporary location for packaging.
  5. **Post-Overlay Hash:** Optionally, the system can compute a hash of the watermarked final image as well (this could serve as an additional fingerprint of the published version). However, the primary fingerprint stored is usually of the original content.
  6. **Database Save:** Creates a new `ImageRecord` entry with all metadata and hash values. Associates it with the current user’s ID and marks status as "Certified" (assuming registration is successful and not disputed). Also logs the action in `ActionLog`.
  7. **Output Preparation:** Calls `certificate.generate_registration_package(record, original, watermarked)` to generate the downloadable package (certificate PDF, watermarked images, etc.). The route then provides this package to the user. For example, it might prompt a download of a ZIP or present a link to download it. It also emails the user a copy or a link, if email notifications are desired.
     After completion, the user can find this image entry in their dashboard. They can always re-download the certificate/package from there (except the original image is not stored, so the original is only provided at registration time).
* `view_image_details(image_id)`: Displays a detailed page for a specific image record (if the current user is the owner or otherwise authorized). This includes all metadata fields, the stored fingerprint/hash values, the current status (e.g., Certified or Disputed), and an activity log of that image (e.g., transfers or flags). For the owner, this page also provides management options:

  * **Download Options:** Buttons to download the certificate or the registration ZIP package (excluding original if not stored). Possibly regenerates or retrieves the watermarked image and certificate on demand.
  * **Edit Metadata:** If allowed, the user can update certain fields (e.g., title, description) if they made a mistake, except those that are intrinsic to the image (like the image hash itself can’t change). This would call an update function to save changes in the DB and log the edit.
  * **Delete Image:** Allows the owner to delete the record if they no longer want it in the registry (perhaps only if it’s not flagged or in dispute). Deletion might require confirmation and would remove the record from the database and logs (or mark it as deleted for audit).
  * **Transfer Ownership:** If the user wants to transfer the image’s ownership to another member (e.g., if they sold the artwork), they can input the recipient’s username/email. This triggers the `transfer_ownership()` route (described next).
* `transfer_ownership(image_id, new_owner_email)`: Processes the transfer of an image record to another registered member. It will verify that the current user is the owner of `image_id` and that the target new owner exists and is eligible (e.g., verified member). On success, it updates the `ImageRecord.owner_id` to the new owner’s user ID, and logs the transfer in the `ActionLog` (including timestamp and parties involved). It may also send notifications to both parties (email to confirm transfer). For transparency, the image’s detail view could maintain a list of past owners or at least log the transfer event accessible to admins or the new owner. (The system does not physically move any image files since none are stored; it’s just a metadata change.)
* `flag_image(image_id)`: Allows a user to flag someone else’s image as disputed. For example, if a member finds an image that they believe is theirs (or infringes their work), they can flag it. This route will mark the `ImageRecord.status` as "Disputed" and perhaps create a separate dispute entry for admin review. It also logs the flag action with details (who flagged it and why, if a reason is provided). Once flagged, the image might be hidden from public lookup until resolved. The admin will get notified through the admin dashboard to review disputes. (Members can also flag their **own** image if they want to revoke it for some reason, which might just set it to a “revoked” status pending admin approval.)
* `manage_overlays()`: (Optional) A page and route for members to upload and manage their signature/watermark images. This interacts with the `OverlayImage` model. Functions under this could include:

  * `upload_signature_image()` – allows user to upload a new signature graphic (e.g., a transparent PNG of their signature or logo). Utilizes `utils.validate_image_file` and virus scan, then saves the file to a secure directory or database and creates an `OverlayImage` entry linked to the user. Possibly resizes it to a max dimension for efficiency.
  * `delete_overlay_image(overlay_id)` – allows user to remove an overlay from their library (if not used in any record, or even if used, removing it would just mean it’s no longer available for new registrations; the past records remain intact with their watermarked outputs).
  * These functions ensure only the owner can manage their overlays. Uploaded overlay images are typically stored on the server (since they will be reused), in contrast to original art images which are not stored.
* `account_settings()`: Provides account management for the member. From here, a user can update their profile info (name, email), change password (with current password verification), enable/disable MFA (`auth.init_mfa`), or link social accounts/public keys if the platform supports verifying identity. It also might allow the user to request **data export or account deletion** to comply with GDPR. For instance, `request_data_export()` would gather all data related to the user (their profile info and list of image records with metadata) and provide it as a downloadable file or email. `request_account_deletion()` would flag the account for deletion – which might execute after a waiting period or admin review, removing personal data while retaining necessary records (perhaps attributing images to an “Anonymous” owner to maintain the integrity of the registry). Proper confirmation and security checks (like re-enter password or email confirmation) are done for these sensitive actions.

**Notes:** Member routes leverage the authentication module (`@require_login`) to ensure only logged-in users access them. The UI for these routes (in templates) will include CSRF tokens and emphasize security (like confirming critical actions). Each action that changes data (register, edit, delete, transfer, flag) writes to the audit log (`ActionLog`) for accountability. Members have the ability to search across the entire image registry (unlike guests) via perhaps an advanced search page or by using the same `lookup_image` functionality but with more details shown if logged in. Privacy settings on images (public/private) can be an option on registration; by default, member images might be private (only visible via direct lookup or to other members) unless the member opts to publish it for public verification.

## 8. `routes_admin.py` – Admin Routes & Tools

**Purpose:** Contains endpoints for administrative users to oversee and manage the platform. Admin routes allow viewing system-wide data, managing users and image records, and handling disputes or flagged content. These routes are protected by strict authorization (admin role only) and include additional safety checks (like requiring MFA for certain destructive actions).

**Key Routes/Functions:**

* `admin_dashboard()`: Shows an overview of the platform’s status (accessible only to admins). This could include statistics (total images registered, total users, number of disputed images, recent activities logs) and quick links to various admin tools (flag review, user management, etc.).
* `list_users()`: Lists user accounts with their roles and status. Admins can see which users are verified, which have MFA, last login times, etc. This might allow actions like toggling a user’s active status (e.g., banning or deactivating an account if necessary for abuse) or elevating a member to an admin role. Functions supporting this could include `set_user_role(user_id, role)` or `deactivate_user(user_id)`.
* `view_flagged_images()`: Shows all images that have been flagged as disputed or auto-marked as potential duplicates. For each, the admin can view details and decide on a resolution. This ties in with a dispute resolution workflow: the admin does not decide ownership, but they might mark records accordingly (e.g., revoke a registration if it’s proven invalid or keep a dispute flag until users resolve it externally).
* `review_image(image_id)`: Provides a detailed view of a particular image record for admin scrutiny. The admin can see everything about the image: full metadata, fingerprint hashes, the watermarked version (since original isn’t stored, only the watermarked image or fingerprint can be reviewed), and the history of actions (who uploaded, any transfers, flags, etc.). From here, the admin can perform actions:

  * **Set Status:** Change the image’s status field (e.g., mark as "Revoked" if an abuse is confirmed, or back to "Certified" if a dispute was resolved amicably). This might be done via a helper `set_image_status(image_id, status, reason=None)`. If revoked, the record might be kept but marked as invalid, and perhaps removed from search results.
  * **Remove Image:** In extreme cases (like illegal content), the admin can delete an image record entirely. This would typically also log an event and possibly notify the owner.
  * **Override Ownership:** In a rare case, if two users agree to swap ownership outside the normal transfer process (or if a mistake in registration needs correction), the admin might manually change the owner of an image via a secure form.
* `duplicate_detection()`: Triggers or displays results of automated duplicate detection. This could run a check on all images comparing perceptual hashes to find possible matches that were not flagged on upload (maybe because they came in around the same time or threshold issues). The admin could review these potential duplicates and flag them for users to resolve.
* `system_logs()`: Allows the admin to browse or search through the `ActionLog`. They could filter by user, by action type, or date to investigate suspicious behavior (e.g., multiple failed logins, or a guest uploading many images rapidly). This helps in **anomaly detection** and responding to security issues.
* `admin_settings()`: (Optional) Interface to adjust certain system-wide settings or view system health. For instance, toggling maintenance mode, updating the list of allowed domains for CORS, viewing server status, etc. Not always needed, but could be included for completeness.

**Notes:** All admin routes use the `@require_login(role="Admin")` decorator to ensure only admins access them. Additionally, for very sensitive actions (like deleting an image or changing a user role), the implementation may require the admin to re-confirm their identity (perhaps re-enter password or an MFA code) to mitigate the risk of an admin session hijack performing critical changes. The admin interface is minimal but focused on trust and safety: the platform itself does not adjudicate copyright (per the project notes), but provides tools to flag and record disputes. The final decision might happen off-platform, but admins can mark the registry to reflect outcomes if provided by the parties (for example, if proof of original authorship is given, admin could revoke the other entry). All these changes are logged for transparency.

## 9. `image_processing.py` – Image Hashing & Fingerprinting Logic

**Purpose:** Handles all the image analysis tasks: generating cryptographic hashes and perceptual fingerprints for images, and performing similarity comparisons. By isolating this logic, it’s easy to update or expand the fingerprinting algorithms without touching the route code.

**Key Functions:**

* `compute_sha256(image_bytes)`: Returns the SHA-256 hash of the given image file (in bytes). This is the primary cryptographic hash stored for each image, providing a unique fingerprint for exact binary matches. It uses a streaming approach to handle large files efficiently and outputs a 64-character hexadecimal string.
* `compute_md5(image_bytes)`: Returns the MD5 hash of the image bytes. This is optional (for legacy or quick comparisons) since MD5 is not secure against collisions, but can be included for backward compatibility or integration with other systems.
* `compute_perceptual_hash(image)`: Calculates a perceptual hash (pHash) of the image content using an algorithm robust to minor changes (like resizing or compression). This might use a library like PIL’s imagehash or OpenCV. It outputs a shorter hash (e.g., 64-bit value often represented in hex) that can be used to find similar images by comparing Hamming distance.
* `extract_orb_features(image)`: Uses OpenCV to extract ORB (Oriented FAST and Rotated BRIEF) feature descriptors from the image. This returns a set of keypoint descriptors that can be stored or used at comparison time to do more fine-grained image similarity checks (especially to catch cases where perceptual hash might fail, like different crops or moderate transformations). The ORB features (or other local feature descriptors like SIFT/SURF if ORB is not sufficient) can be serialized (perhaps as a binary blob or base64 string) into the `fingerprint` field of the ImageRecord.
* `generate_fingerprint(image)`: High-level function that combines the above methods to produce a comprehensive fingerprint object. For example, it opens the image (Pillow), may convert it to a standard format (e.g., normalize size or mode), then computes the SHA-256, perceptual hash, and ORB features. It returns a structure (dictionary or custom object) containing all these values. This is used during registration to populate the ImageRecord.
* `compare_hashes(hash1, hash2)`: A simple utility to compare two hash strings (SHA-256 or MD5) for equality. Used to check if an exact file has been seen before.
* `phash_similarity(phash1, phash2)`: Computes the similarity (or distance) between two perceptual hashes. Typically, this calculates the Hamming distance (number of differing bits). If the distance is below a certain threshold, the images are considered similar. This is used for searching the database for near matches of a given image.
* `find_similar_images(image_or_phash)`: Given an input image (or a perceptual hash), this function scans the database for images with perceptual hashes within a certain similarity threshold. It may return a list of `ImageRecord` matches with their similarity scores. This supports the lookup feature and duplicate detection. If using ORB, an enhanced version could match features between the input and stored ORB features for more accuracy, but at higher computational cost.
* `resize_image(image, max_dimensions)`: Utility to resize an image to given max width/height while preserving aspect ratio. Used for creating thumbnails or social-media-optimized images (for example, creating the low-resolution copy for the registration package).
* `convert_to_standard_format(image)`: Ensures the image is in a standard format (such as converting to JPEG or PNG at a standard color profile). This can help ensure consistent hashing (some hashes might differ if metadata or color profile differ, so we might strip metadata here as well). This function might be called internally before hashing.
* `remove_image_metadata(image)`: (Optional) Strips EXIF and other metadata from the image. This can protect privacy (no location or camera info leaks) and also ensure that the cryptographic hash is based solely on image content, not metadata. In practice, one might compute hash on the raw file including metadata for uniqueness, **and** store a hash of the image pixels alone for a content-based fingerprint. This function would be used if we decide to do the latter.

**Notes:** The combination of SHA-256 and perceptual hash provides both exact verification and similarity search. ORB feature storage is an advanced feature to improve duplicate detection for images that have minor edits. For instance, if someone adds a small border or slightly alters an image, the perceptual hash might catch it, but ORB can provide more robust matching by looking at keypoint descriptors. This file could also include integration with any external image matching service or future ML-based image fingerprinting, but the above functions cover the current scope. All operations here are done in-memory (the original image file is loaded, processed, and not stored permanently). Heavy computations (like ORB feature extraction) are kept efficient and possibly done in a background thread or with a timeout to avoid slowing down the web request (alternatively, the registration route might offload this to a task queue if performance is a concern).

## 10. `watermark.py` – Watermark & Signature Overlay Functions

**Purpose:** Provides functionality to embed watermarks (text or image signatures) into images. This module handles overlaying text or images onto the original image with specified positions, colors, and opacity. It ensures the process is flexible (multiple overlays) but also secure (watermarks are optional and meant for user’s benefit).

**Key Functions:**

* `apply_text_watermark(image, text, position, color="#FFFFFF", opacity=0.3)`: Overlays a semi-transparent text string onto the given image at the specified position. Position might be an enum/string (like "top-left", "center", etc.) which this function translates into pixel coordinates. It uses a default color (white, for example) and opacity if not provided, and chooses an appropriate font and size (possibly dynamically based on image size). This function returns a new image object with the text rendered on it. It ensures the text is clearly visible but not too obtrusive.
* `apply_image_watermark(image, overlay_img, position, opacity=0.3)`: Overlays another image (such as a signature image or logo) onto the base image. It will resize the overlay if needed (for example, making sure it doesn’t cover more than a certain percentage of the artwork). Position works similarly to the text watermark function. If the overlay image has transparency (alpha channel), that is preserved; otherwise, an opacity parameter is applied to blend it. The result is a new image with the overlay.
* `apply_overlays(image, overlays)`: A higher-level function to apply multiple overlays in sequence. The `overlays` parameter could be a list of overlay instructions (each containing type "text" or "image", the content or reference, position, color/opacity as needed). This function will iterate and apply each one by calling the appropriate helper (text or image). It ensures that the overlays are applied on the original in the correct order. For instance, a user might want a signature image at the bottom-right and a text copyright notice at the top-left – both would be applied. The function returns the fully watermarked image. It may also refuse to apply more than the allowed number of overlays (enforcing the limit of three).
* `generate_social_image(image)`: Creates a smaller, low-resolution version of the provided (watermarked) image suitable for sharing on social media or web. This function likely uses `image_processing.resize_image` to scale the image down (e.g., max 800px width) and possibly increases the watermark visibility if needed (since resizing can make watermarks harder to see). The output is an image file that will be included in the registration package for easy sharing.
* `preview_watermark(image, overlays)`: (Optional, for future UI use) Could generate a quick preview of how the watermarks will look on an image without saving anything. This might be used if the front-end allows the user to position overlays interactively. For now, it might not be needed since the positioning is chosen from preset options.

**Notes:** This module does not permanently store any image; it simply takes in-memory images and returns new images after overlay. It should handle various image modes (RGB, RGBA) properly. All overlay parameters are validated (e.g., text length, image overlay file size) to prevent misuse (like someone uploading a huge overlay image). Because members can upload their own signature images, those images are provided to this module likely as Pillow Image objects after being fetched from storage (since `OverlayImage` path can be loaded). This module might rely on Pillow for text drawing and alpha compositing. By abstracting watermark logic here, the core registration process can remain clean and just call `apply_overlays`.

## 11. `certificate.py` – Certificate & Package Generation

**Purpose:** Handles creation of proof-of-authenticity documents and packaging of outputs for the user. When an image is registered, this module is responsible for generating the downloadable certificate (PDF/JSON) and bundling the various image files into a ZIP. This ensures the user gets all necessary evidence of registration in a convenient format.

**Key Functions:**

* `generate_certificate(image_record, output_format="PDF")`: Creates a **certificate of authenticity** for the given `ImageRecord`. This includes all important metadata: title, creator/artist name, registration date/time, unique registration ID or hash, and perhaps the license type or a brief copyright notice. It also can embed a QR code that encodes the lookup URL (so anyone scanning it can be taken to the public verification page for this image). In PDF mode, it uses a PDF library (like ReportLab or WeasyPrint) to lay out this information in a visually appealing manner (possibly with the platform logo and a signature line for the artist). In JSON mode (if requested or for API), it would structure the data in JSON format. This function returns the path to the generated certificate file or a file object.
* `create_registration_package(image_record, original_image, watermarked_image, signature_only_image=None)`: Packages all relevant files into a ZIP archive for the user to download. Contents typically include:

  * **Certificate**: The PDF generated by `generate_certificate`.
  * **Original Image**: The exact image the user uploaded (in its original form). *Note:* This is included only at the time of registration. The system itself does not retain this file permanently; it is added to the ZIP and then deleted from the server. This gives the user a backup of what they uploaded, in case they need to prove the original content.
  * **Watermarked Image**: The final image with all overlays applied. This is the version the user can share or use, containing their watermark/signature.
  * **Signature-only Image**: If the user provided a signature overlay (image of their signature) and possibly a text watermark, the package can include a version of the image with only the signature applied (no text watermark). This could be useful for the artist to have a copy that just shows their signature on the artwork. Alternatively, this could refer to just the signature overlay file itself for reference. (This item is optional or conditional based on what overlays were used.)
  * **Social Image**: A downsized watermarked image for web/social sharing (as generated by `generate_social_image` in `watermark.py`).
  * **Metadata Summary**: Optionally, a text or JSON file that lists all the metadata fields and hashes for the image, serving as a digital record. This could be a `.json` file containing the ImageRecord data, or integrated in the certificate.
    The function will gather all these components, compress them into a single `.zip` file (using Python’s zipfile or shutil libraries), and return the path to this archive. After the response is delivered to the user, the server may clean up the temporary files (original image, zip, etc.).
* `generate_qr_code(data)`: Helper to generate a QR code image (PNG) that encodes a URL or text. In this context, it would encode the public lookup URL for the image (e.g., `https://imageproof.com/verify?hash=XYZ...`). This QR code is embedded in the PDF certificate so that anyone with a printed certificate can easily scan to verify online. This function can use a library like qrcode or an API.
* `email_package(user, package_path)`: (Optional) Sends an email to the user with the certificate and package attached or linked. After successful registration, the system can use this to ensure the user has a copy even if they navigate away. This function would use SMTP or an email service, with proper templating for the email content (noting what was registered and when).

**Notes:** The certificate generation should use the **legal templates** and license information stored in the system. For example, if the user selected a certain license type, the certificate might include a paragraph from a template like "This artwork is licensed under {LicenseName} - {LicenseURL}" or attach a text of the license. The certificate might also include a unique ID or code that is stored in the database for verification. All PDF or text outputs should be encoded in UTF-8 to support international text. Additionally, if needed for compliance, this module could also generate a log of registration in a separate ledger (for example, a simple blockchain or an IPFS upload) – not in scope now, but designed such that one could hook in an external archival step in this process.

## 12. **HTML Templates** (Frontend Pages)

**Purpose:** A collection of Jinja2 (or similar) templates to render the frontend pages of the web application. These define the structure and layout of the user interface for all the routes described above. We group them here as they are not Python scripts, but it’s important to plan their existence. Each template is designed with security in mind (escaping content, including CSRF tokens in forms) and a responsive UI (possibly using Tailwind CSS or custom CSS). Key templates include:

* `base.html`: The base layout template, containing common elements like the navigation bar (with links for Home, Dashboard, Login/Logout, etc. depending on user state), footer, and inclusion of CSS/JS files. Other pages extend this base template. It also includes a banner or alert section for flash messages (like success or error notifications).
* `index.html`: The public home page (viewed in `home_page()` route). Explains the platform and provides a quick lookup form. It might have a simple form to enter an image hash or upload an image for verification directly, which submits to the public `lookup_image` route. If the user is logged in, it may show a summary of their dashboard or a prompt to go to dashboard instead.
* `register_image.html`: The form for members to register a new artwork (used by `register_image_member()`). This form will have fields for all metadata (Title, Description, Date, etc. as per the schema), file inputs for the original image and optional overlay images (or selection of existing signature images), and input for watermark text with options (color, position). It will include a hidden CSRF token for security. The form might use some JavaScript to, for example, preview the selected image or watermark positioning (if implementing preview functionality). For guests, a simplified version `register_guest.html` (or the same form dynamically adjusted) would show fewer options (only text watermark, and maybe fewer metadata fields).
* `dashboard.html`: The member’s dashboard page (viewed in `dashboard()` route). Displays a table or gallery of the user’s registered images (likely just thumbnails or titles, since we do not store full images, we might store a thumbnail or use the watermarked image as a thumbnail). Each entry has actions like “View Details”, and indicators like status (e.g., Disputed flag icon if applicable). Also on this page could be a button to “Register New Image” leading to the register form, and maybe summary stats (e.g., number of images, any pending transfers).
* `image_detail.html`: Shows details for a single image record (for owners or admins). It lists all the metadata fields in a structured way, shows the watermarked image (embedded or as a thumbnail), and provides buttons for the owner actions (download certificate, transfer, delete, etc., as appropriate given the user’s permissions). If the image is disputed or revoked, it might highlight that with a message. If the viewer is an admin, this page might extend to show extra info like logs and admin actions.
* `lookup_results.html`: Displays the outcome of an image search (used by `lookup_image()`). If a hash or image was searched, this page will list any matching records. Each result might show a small preview (if available) and some info like title, artist, and status. If the viewer is a guest and the match is a member’s private entry, it might just say “Registered (Private)” or prompt login to see details. If the image is public or a guest submission, it might show more info. In case of no match, the page would indicate the image is not found in the registry. This page also provides a form or link to register the image if it’s theirs (encouraging sign-up or use of the service).
* `login.html` & `signup.html`: Forms for user authentication (used by routes in `auth.py`). The login form asks for email, password, and if the account has MFA, possibly a code (maybe the code field is shown after initial password verification). The signup form asks for email, password, username, etc., and includes a CAPTCHA widget if enabled. Both forms include CSRF tokens.
* `admin_dashboard.html`: The landing page for admin section (used by `admin_dashboard()` route). Shows admin stats and links as described earlier. Likely extends `base.html` but with admin-specific navigation.
* `flagged_list.html` / `flagged_detail.html`: Pages for viewing flagged/disputed images list and details (for admins). The list page shows all disputes and duplicates, and the detail page (which could reuse `image_detail.html` with admin privileges) allows taking action.
* `account_settings.html`: Form for user to update profile, change password, and manage MFA (part of `account_settings()` route). It would allow toggling MFA (maybe showing a QR if enabling), and buttons to request data export or account deletion, with proper warnings.

**Notes:** All templates use **secure coding practices**: escaping variables, not trusting any user-generated content (which should already be sanitized server-side). They also include necessary scripts for usability (for example, using a JS snippet to handle image preview on the register form, or to confirm dangerous actions like deletion or transfer). Styling can be done via Tailwind classes or a custom `styles.css`. The templates folder keeps the structure organized (possibly subfolders for admin, etc., depending on preference).

## 13. **Static Files** – CSS, JavaScript, and Assets

**Purpose:** Contains static client-side files, including stylesheets, scripts, and images needed for the web interface. While not "code files" in the same sense, they are essential for the project’s completeness and user experience. Key files in this category include:

* **`styles.css`**: The main stylesheet for the application’s custom styling. If using Tailwind CSS, this might be a generated file (or we include Tailwind via CDN and only have a small custom CSS). This file defines the look and feel: colors, layout adjustments, and ensures the site is mobile-friendly. It also might include styles for the watermark text preview or any specific visual elements of the certificate if displayed on site.
* **`main.js`**: The primary JavaScript file for client-side interactions. This can handle tasks such as:

  * Previewing watermark overlays on the registration form (for example, showing the text overlay on the displayed image before submission).
  * Handling the drag-and-drop image lookup on the homepage (allowing a user to drop an image file onto a search area which then triggers an upload to `lookup_image` via AJAX).
  * Managing form enhancements and validations on the client side for better UX (though server-side validation is the primary).
  * Possibly interfacing with the CAPTCHA if one is used, or any API calls (like maybe doing the lookup via AJAX and showing results without full page reload).
* **Images/Assets**: Any site images like the platform logo, icons (e.g., an icon for certified or disputed status), and favicon. Also, if the project uses a default image for previews or a placeholder for user’s signature before uploaded, it would reside here.
* **Tailwind Config (optional)**: If Tailwind CSS is used and we are customizing it, a config file might be present (typically `tailwind.config.js`) and perhaps a script to build the CSS. However, these could be part of the build process and not counted among the core files, depending on the setup.

**Notes:** Static files are served by the web server as-is. Security considerations include setting proper HTTP headers (via the app) for these files (like content security policy (CSP) to restrict where scripts can load from, and cache headers). Also, ensure that user-uploaded content (like overlay images) is not placed directly in this public static directory unless intended; those should be protected (perhaps stored outside static and served via a controlled route or at least with unpredictable names) to prevent unauthorized access.

## 14. `schema.sql` – Database Schema Definition Script

**Purpose:** An SQL script to create the initial database schema for ImageProof. This is used to set up the MariaDB with the required tables and columns corresponding to the models. It is an alternative to using an ORM migration and is useful for quickly understanding the database structure.

**Contents:** (Plain English overview of SQL statements)

* **Users Table:** Creates a `users` table with columns: `id` (INT, primary key), `email` (VARCHAR(255), unique), `password_hash` (VARCHAR(255)), `username` or name (VARCHAR(255)), `role` (ENUM of 'Guest','Member','Admin'), `email_verified` (TINYINT as boolean), `mfa_secret` (VARCHAR for storing MFA setup, nullable), `created_at` (DATETIME), `last_login` (DATETIME), etc. Ensures an index on email for login and unique constraint for integrity.
* **Images Table:** Creates an `images` table with columns for all the metadata fields outlined in the schema. Key columns include: `id` (INT PK), `owner_id` (INT, foreign key to users.id, can be NULL for guest submissions), `title` (VARCHAR(255)), `description` (TEXT), `creation_date` (DATE), `keywords` (TEXT), `genre` (TEXT for intellectual genres/tags), `creator_name` (VARCHAR), `byline` (VARCHAR), `copyright_notice` (VARCHAR), `license_type` (VARCHAR or smallint referencing a licenses table), `info_url` (VARCHAR for any reference URL), `image_url` (VARCHAR if an external URL provided), `watermark_text` (TEXT, optional), `watermark_position` (ENUM of positions), `watermark_color` (VARCHAR(7) for hex color), `signature_image_id` (INT, foreign key referencing an overlay image if used), `watermark_image_id` (INT, foreign key referencing overlay if an additional watermark graphic used), `fingerprint` (TEXT or JSON to store complex fingerprint data like ORB features), `sha256_hash` (CHAR(64)), `phash` (CHAR(16) or appropriate length for perceptual hash), `md5_hash` (CHAR(32), optional), `status` (ENUM: 'Certified','Disputed','Revoked','Deleted'), `registered_at` (DATETIME), `flagged_at` (DATETIME, if ever flagged), etc. Add indexes on `sha256_hash` (unique) and `phash` (perhaps a normal index for lookup). Also consider an index on `owner_id` for querying user’s images, and on `status` for admin queries.
* **OverlayImages Table:** Creates an `overlay_images` table for user-uploaded overlay files. Columns: `id` (INT PK), `user_id` (INT, FK to users), `filename` or `path` (VARCHAR to reference where the file is stored), `type` (ENUM: 'signature','watermark'), `uploaded_at` (DATETIME). Possibly store an `md5_hash` of the overlay file to detect duplicate overlays or reuse. Index on `user_id`.
* **ActionLog Table:** Creates an `action_log` table. Columns: `id` (INT PK), `user_id` (INT, FK to users, nullable for system actions), `image_id` (INT, FK to images, nullable), `action` (VARCHAR(50)), `timestamp` (DATETIME), `details` (TEXT). Index on `image_id` and `user_id` for filtering logs. This table can grow large, so consider partitioning or periodic cleanup of old entries if necessary (except those needed for audit).
* **Licenses Table (optional):** If we want to store license types and templates in DB, create a `licenses` table with `id`, `name` (e.g., "All Rights Reserved", "CC BY-NC", etc.), `template_text` (TEXT for the legal text or a URL to license details). The `license_type` field in images table could then be a FK to this table’s id instead of free text. Pre-populate with common licenses.
* **Other Constraints:** Add foreign key constraints linking `images.owner_id -> users.id`, `images.signature_image_id -> overlay_images.id`, etc., with cascade on delete or appropriate rules (e.g., if a user is deleted, maybe their images become ownerless or are also removed; if an overlay is deleted, set the reference in images to NULL but generally overlays in use might be prevented from deletion).

**Notes:** This schema is designed to satisfy the data requirements. If using an ORM, these SQL statements correspond to model definitions. The script would be executed once to set up the initial database. All text fields use appropriate encodings (UTF8) for international characters. The use of separate tables for overlays and licenses is to normalize the data and allow reusability. If simplicity is preferred, license types could be just stored as text in the images table and overlays could be stored on filesystem with paths in images table; however, the separated design is cleaner and more extensible.

## 15. `seed_data.sql` – Initial Data Seeding Script

**Purpose:** Provides initial data inserts for certain tables that require predefined values or templates. This helps bootstrap the application with some necessary information (especially license templates and possibly admin account).

**Contents:**

* **License Types:** Insert statements for the `licenses` table (if used). For example, add entries for common licenses: "All Rights Reserved" (with appropriate template or text), "CC0", "CC BY 4.0", etc., and any custom licenses or notices that might be offered. Each entry might include a short code or description and full text.
* **Copyright Notice Templates:** If there's a separate need for storing copyright notice formats (as the notes mention a dropdown or custom text for copyright field), we could insert some default options like `"© {ArtistName} {Year}"`, `"© {Year} {ArtistName}, All Rights Reserved"`, etc., which can be referenced in the front-end dropdown. This might be part of the licenses table or a separate small table; the seed file would populate them.
* **Default Admin User:** Optionally, create an initial admin account (especially for development). This would insert into `users` a record like admin with a pre-defined password hash. In production, it might be better to create admin via a secure process instead, so this could be commented out or omitted.
* **Test Data (Optional):** Could include some sample entries (like a dummy image record or user) for testing purposes, but normally not in production seed.

**Notes:** If using an ORM migration/seed framework, these inserts could be done via a Python script instead. However, having an SQL seed file is straightforward for initial setup. After running `schema.sql` and `seed_data.sql`, the application will have the necessary static data to operate (license options available, etc.). The seed file should be idempotent (or documentation should warn to only run once) to avoid duplicate entries.

## 16. **Tests/** – Test Suite for the Application

**Purpose:** Although not detailed in the initial plan, a robust project includes tests. The tests directory contains automated tests to ensure the integrity and security of the system. They help verify that each component behaves as expected (unit tests) and that the system as a whole works (integration tests). We group the test files as one entry here. Key test files might include:

* `test_utils.py`: Unit tests for functions in `utils.py` (e.g., ensuring `sanitize_text` properly strips dangerous content, `hash_password` and `verify_password` work together, and that `scan_file_for_viruses` correctly identifies a safe vs EICAR test file, perhaps mocked).
* `test_image_processing.py`: Tests for hashing and fingerprinting. For example, ensure that `compute_sha256` on known input produces expected hash, `compute_perceptual_hash` yields the same value for two identical images and different for distinct images, and that `find_similar_images` finds images within a threshold. Could use small sample images for this.
* `test_watermark.py`: Tests that applying watermarks does not alter image dimensions and that the output image indeed contains the text or overlay (this might be done by checking pixel values or just that the function runs without error and outputs an image of expected mode/size). Also test combining multiple overlays.
* `test_auth.py`: Tests the authentication logic – e.g., registering a user (with a dummy email backend), login success/failure scenarios, password hashing comparisons, and MFA verification (perhaps simulating a TOTP code). Also test that the `require_login` decorator blocks access when not logged in.
* `test_routes.py`: Integration tests for the Flask app routes using a test client. This would include ensuring that protected routes require login, that public routes return expected data, and a full flow test where a user registers an image and then looks it up by hash. We’d simulate file upload for image registration and check that the database entries are created and that the response contains the expected package or confirmation. Also test edge cases like duplicate image upload, flagging an image, and admin actions.

**Notes:** Security-critical behaviors should be tested, such as: an unprivileged user cannot access admin URLs (expect 403), a guest cannot delete someone’s image via crafted request, CSRF tokens are required on POST forms (test by omitting token to see if it’s rejected). Performance aspects (like rate limiting) can be tested by simulating rapid requests and ensuring the app responds with a rate-limit message after the threshold. The tests ensure that as new changes are made, the core functionality and security measures remain intact.

---

Each of these files/modules plays a specific role in the ImageProof project. Together, they implement a secure, organized system for registering and verifying digital artworks. By following this structured roadmap, the development can proceed in a modular fashion: for example, one can start by setting up the database models and schema, then implement the hashing in `image_processing.py`, then the overlay logic, and so forth, finally wiring them together in the route handlers. Security has been woven into every layer (from input validation to audit logging) to make the platform robust against misuse. This plan stays within the 20-file limit by grouping related functionalities and will serve as a guide for building the ImageProof application.
